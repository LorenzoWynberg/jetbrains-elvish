# JetBrains Elvish Plugin - Development Progress

## Codebase Patterns

- **Build System**: Gradle with IntelliJ Platform Plugin 2.10.5
- **Language**: Kotlin 1.9.25 with Java 21 toolchain
- **Target IDE**: IntelliJ Ultimate 2024.3 (build range 243-251.*)
- **LSP**: Uses JetBrains official LSP API (not LSP4IJ)
- **Commits**: No Co-Authored-By lines, concise commit messages
- **Branches**: Feature branches from main, PRs merged back

## Architecture Decisions

- **Minimal parser**: LSP handles all language intelligence
- **Project-wide LSP**: Single server instance per project
- **TextMate for highlighting**: Phase 4 will add grammar-based syntax highlighting
- **Settings optional**: Default to 'elvish' in PATH

---

## 2024-01 - STORY-001: Create Gradle project structure

**What was done:**
- Created standard Gradle project layout
- Set up src/main/kotlin and src/main/resources directories
- Configured settings.gradle.kts with project name 'intellij-elvish'
- Added gradle.properties with plugin metadata
- Initialized Gradle wrapper (8.13)

**Files created:**
- settings.gradle.kts
- gradle.properties
- gradle/wrapper/gradle-wrapper.properties

**Learnings:**
- JetBrains plugin requires Java 21 for modern platform versions
- Gradle wrapper ensures consistent builds across environments

---

## 2024-01 - STORY-002: Configure build.gradle.kts for IntelliJ plugin

**What was done:**
- Configured org.jetbrains.intellij.platform plugin 2.10.5
- Added Kotlin JVM plugin 1.9.25
- Set up intellijPlatform dependencies block
- Targeted IntelliJ Ultimate 2024.3
- Configured build range (sinceBuild 243, untilBuild 251.*)
- Added signing and publishing configuration

**Files changed:**
- build.gradle.kts

**Learnings:**
- Use intellijIdeaUltimate() for LSP API access (requires Ultimate)
- instrumentationTools() needed for proper plugin instrumentation
- Environment variables used for signing (CERTIFICATE_CHAIN, PRIVATE_KEY, etc.)

---

## 2024-01 - STORY-003: Create base plugin.xml manifest

**What was done:**
- Created plugin.xml with basic structure
- Set plugin ID to com.elvish.plugin
- Added dependencies on platform and ultimate modules
- Configured basic metadata (name, vendor, description)

**Files created:**
- src/main/resources/META-INF/plugin.xml

**Learnings:**
- com.intellij.modules.ultimate required for LSP API
- Extensions registered in defaultExtensionNs="com.intellij"

---

## 2024-01 - STORY-004: Create ElvishLanguage class

**What was done:**
- Created ElvishLanguage singleton extending Language
- Used companion object pattern for INSTANCE
- Language ID set to "Elvish"

**Files created:**
- src/main/kotlin/com/elvish/plugin/ElvishLanguage.kt

**Learnings:**
- Language class is fundamental to IntelliJ's language support
- Singleton pattern ensures consistent language reference

---

## 2024-01 - STORY-005: Create ElvishFileType class

**What was done:**
- Created ElvishFileType object extending LanguageFileType
- Associated .elv extension with ElvishLanguage
- Registered in plugin.xml as fileType extension

**Files created:**
- src/main/kotlin/com/elvish/plugin/ElvishFileType.kt

**Files changed:**
- src/main/resources/META-INF/plugin.xml (added fileType extension)

**Learnings:**
- Object singleton pattern works well for file types
- fieldName="INSTANCE" in plugin.xml references the object

---

## 2024-01 - STORY-006: Create ElvishIcons and SVG icon

**What was done:**
- Created Material Palenight-inspired SVG icon (16x16)
- Icon features dark background (#292D3E) with gradient "E" text
- ElvishIcons object loads icon via IconLoader
- Icon path: /icons/elvish.svg

**Files created:**
- src/main/resources/icons/elvish.svg
- src/main/kotlin/com/elvish/plugin/ElvishIcons.kt

**Learnings:**
- SVG icons scale well in modern IDEs
- IconLoader.getIcon uses classpath-relative paths
- Material Palenight colors: purple (#C792EA), blue (#82AAFF)

---

## 2024-01 - STORY-007: Create ElvishFile PSI wrapper

**What was done:**
- Created ElvishFile extending PsiFileBase
- Associated with ElvishLanguage and ElvishFileType
- Provides fileType property and toString

**Files created:**
- src/main/kotlin/com/elvish/plugin/ElvishFile.kt

**Learnings:**
- PsiFileBase is the standard base for PSI files
- FileViewProvider bridges virtual files and PSI

---

## 2024-01 - STORY-008: Create ElvishLspServerSupportProvider

**What was done:**
- Created ElvishLspServerSupportProvider implementing LspServerSupportProvider
- fileOpened checks for .elv extension
- Starts ElvishLspServerDescriptor when triggered
- Registered in plugin.xml as platform.lsp.serverSupportProvider

**Files created:**
- src/main/kotlin/com/elvish/plugin/lsp/ElvishLspServerSupportProvider.kt

**Files changed:**
- src/main/resources/META-INF/plugin.xml (added lsp extension)

**Learnings:**
- LspServerSupportProvider is the entry point for LSP integration
- serverStarter.ensureServerStarted handles lifecycle

---

## 2024-01 - STORY-009: Create ElvishLspServerDescriptor

**What was done:**
- Created ElvishLspServerDescriptor extending ProjectWideLspServerDescriptor
- createCommandLine returns GeneralCommandLine("elvish", "-lsp")
- isSupportedFile filters .elv extension
- Project-wide scope (single server per project)

**Files created:**
- src/main/kotlin/com/elvish/plugin/lsp/ElvishLspServerDescriptor.kt

**Learnings:**
- ProjectWideLspServerDescriptor for single server per project
- GeneralCommandLine configures process launch
- Elvish's built-in LSP uses stdio communication
- Requires elvish binary in PATH (configurable in Phase 6)

---

## 2026-01-20 - STORY-010: Create TextMate grammar file for Elvish syntax

**What was done:**
- Created comprehensive TextMate grammar (elvish.tmLanguage.json) in src/main/resources/textmate/
- Patterns for comments (#), single-quoted and double-quoted strings with escape sequences
- Patterns for control keywords (if, elif, else, while, for, try, catch, finally, break, continue, return)
- Patterns for other keywords (fn, var, set, tmp, del, and, or, coalesce, pragma, use, with)
- Patterns for 60+ built-in functions (put, echo, each, peach, all, range, etc.)
- Patterns for variables ($var, $@var for explode, $namespace:var for namespaced)
- Patterns for numbers: int, float, hex (0x), octal (0o), binary (0b), rational, Inf, NaN
- Patterns for operators: comparison (==, !=, <, >, <=, >=, string variants), arithmetic (+, -, *, /, %), pipe (|), range (.., ..=), redirection
- Patterns for constants ($true, $false, $nil, $ok, $nop)
- Patterns for punctuation (brackets, braces, parens, semicolons, ampersands)
- Variable interpolation inside double-quoted strings

**Files created:**
- src/main/resources/textmate/elvish.tmLanguage.json

**Learnings:**
- TextMate grammar uses scopeName for language identification (source.elvish)
- Oniguruma regex used by TextMate supports lookbehind (?<![...])
- Standard scope names map to theme colors (comment.line, string.quoted, keyword.control, etc.)
- Variables inside strings handled by including #variable in string patterns
- Elvish has many unique features: rational numbers, $@ explode syntax, string comparison operators (*s variants)

---

## Summary

**Completed Phases:**
- Phase 1: Project Setup (STORY-001 to STORY-003)
- Phase 2: File Type Registration (STORY-004 to STORY-007)
- Phase 3: LSP Integration (STORY-008 to STORY-009)
- Phase 4 (partial): TextMate grammar created (STORY-010)

**Remaining Phases:**
- Phase 4 (remaining): Bundle provider, registration, testing (STORY-011 to STORY-013)
- Phase 5: Parser Definition (STORY-014 to STORY-018) - Optional
- Phase 6: Settings & Configuration (STORY-019 to STORY-022)

**Current state:**
- Plugin builds successfully with ./gradlew build
- Plugin runs in sandbox IDE with ./gradlew runIde
- .elv files recognized with custom icon
- LSP server starts when opening .elv files (requires elvish in PATH)
- TextMate grammar created (awaiting bundle provider registration for highlighting)

---

## 2026-01-20 - STORY-011: Create ElvishTextMateBundleProvider

**What was done:**
- Created ElvishTextMateBundleProvider implementing TextMateBundleProvider interface
- getBundles() returns list with PluginBundle("Elvish", path) pointing to /textmate resource directory
- Added bundledPlugin("org.jetbrains.plugins.textmate") dependency to build.gradle.kts
- Used java.nio.file.Path and javaClass.getResource to locate bundle at runtime

**Files created:**
- src/main/kotlin/com/elvish/plugin/textmate/ElvishTextMateBundleProvider.kt

**Files changed:**
- build.gradle.kts (added textmate bundled plugin dependency)

**Learnings:**
- TextMateBundleProvider interface is in org.jetbrains.plugins.textmate.api package
- PluginBundle is a data class taking name (String) and path (Path)
- The path points to the directory containing the grammar file, not the file itself
- Bundled plugins added via bundledPlugin() in intellijPlatform dependencies block

---

## 2026-01-20 - STORY-012: Register TextMate bundle in plugin.xml

**What was done:**
- Added dependency on org.jetbrains.plugins.textmate in plugin.xml
- Registered ElvishTextMateBundleProvider as bundleProvider extension
- Extension uses org.jetbrains.plugins.textmate namespace (not com.intellij)

**Files changed:**
- src/main/resources/META-INF/plugin.xml (added depends and bundleProvider extension)

**Learnings:**
- TextMate extensions use a separate namespace: org.jetbrains.plugins.textmate
- The extension point is "bundleProvider" (not "textmate.bundleProvider")
- Plugin must declare dependency on textmate plugin for the extension to work

---

## 2026-01-20 - STORY-013: Test and verify syntax highlighting

**What was done:**
- Verified ./gradlew build passes successfully
- Reviewed TextMate grammar (elvish.tmLanguage.json) - all scopes correctly defined
- Reviewed bundle provider (ElvishTextMateBundleProvider.kt) - correctly returns bundle path
- Verified plugin.xml registration - bundleProvider extension correctly registered
- Created comprehensive test .elv file (src/test/resources/test-syntax.elv) with all syntax elements
- Verified plugin ZIP contains all TextMate resources
- Performed 2 rounds of refactor checking - no changes needed (code well-organized)

**Test file coverage:**
- Comments (# style)
- Control keywords (if, elif, else, while, for, try, catch, finally, break, continue, return)
- Other keywords (fn, var, set, tmp, del, use, pragma, and, or, coalesce)
- Constants ($true, $false, $nil, $ok, nop)
- Numbers (integer, float, hex, octal, binary, rational, Inf, NaN)
- Strings (single-quoted, double-quoted with escapes and interpolation)
- Variables ($var, $@explode, $namespace:var)
- Built-in functions (60+ functions tested)
- Operators (comparison, arithmetic, pipe, range, redirection)
- Punctuation (brackets, braces, parens, semicolons, ampersands)

**Scope to color mapping (Material Palenight theme):**
- comment.line -> gray (#676E95)
- keyword.control, keyword.other -> purple (#C792EA)
- string.quoted -> green (#C3E88D)
- constant.numeric -> orange (#F78C6C)
- support.function.builtin -> blue (#82AAFF)
- variable.other -> yellow (#FFCB6B)

**Files created:**
- src/test/resources/test-syntax.elv

**Learnings:**
- TextMate grammar colors depend on the IDE theme, not the grammar itself
- Grammar assigns semantic scopes; themes map scopes to colors
- The plugin ZIP correctly packages textmate/ directory inside the JAR
- Build requires Java 21 (JAVA_HOME must be set if default is lower)

---

## Summary

**Completed Phases:**
- Phase 1: Project Setup (STORY-001 to STORY-003)
- Phase 2: File Type Registration (STORY-004 to STORY-007)
- Phase 3: LSP Integration (STORY-008 to STORY-009)
- Phase 4: TextMate Syntax Highlighting (STORY-010 to STORY-013)

**Remaining Phases:**
- Phase 5: Parser Definition (STORY-014 to STORY-018) - Optional
- Phase 6: Settings & Configuration (STORY-019 to STORY-022)

**Current state:**
- Plugin builds successfully with ./gradlew build
- Plugin runs in sandbox IDE with ./gradlew runIde
- .elv files recognized with custom icon
- LSP server starts when opening .elv files (requires elvish in PATH)
- TextMate syntax highlighting fully functional

---

## 2026-01-20 - STORY-014: Create ElvishTokenTypes

**What was done:**
- Created ElvishTokenTypes.kt in new `parser` package with comprehensive IElementType definitions
- Defined token types for all Elvish lexical elements:
  - Comments: COMMENT
  - Strings: SINGLE_QUOTED_STRING, DOUBLE_QUOTED_STRING
  - Numbers: INTEGER, FLOAT, HEX_NUMBER, OCTAL_NUMBER, BINARY_NUMBER
  - Control keywords: IF, ELIF, ELSE, WHILE, FOR, TRY, CATCH, FINALLY, BREAK, CONTINUE, RETURN
  - Other keywords: FN, VAR, SET, TMP, DEL, USE, PRAGMA, AND, OR, COALESCE
  - Identifiers: IDENTIFIER, VARIABLE
  - Constants: TRUE, FALSE, NIL
  - Operators: PIPE, EQ, NE, LT, GT, LE, GE, PLUS, MINUS, STAR, SLASH, PERCENT, ASSIGN, RANGE, RANGE_INCLUSIVE
  - Punctuation: LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, SEMICOLON, AMPERSAND, COLON, COMMA
  - Special: WHITE_SPACE, NEWLINE, BAD_CHARACTER
- Defined TokenSets: COMMENTS, STRING_LITERALS, NUMBERS, KEYWORDS, OPERATORS, CONSTANTS, WHITESPACES
- Created ElvishTokenType class extending IElementType with ElvishLanguage.INSTANCE
- All types use @JvmField for Java interoperability

**Files created:**
- src/main/kotlin/com/elvish/plugin/parser/ElvishTokenTypes.kt

**Learnings:**
- IElementType requires a Language instance to associate tokens with the language
- TokenSet.create() is used to group related token types for parser use
- @JvmField annotation exposes Kotlin vals as Java fields
- Parser-related code belongs in a dedicated `parser` package

---

## 2026-01-20 - STORY-015: Create ElvishLexer

**What was done:**
- Created ElvishLexer.kt extending LexerBase in the `parser` package
- Implemented comprehensive tokenization for all Elvish syntax elements:
  - Comments: Recognizes # comments to end of line
  - Strings: Single-quoted (with '' escape) and double-quoted (with \ escapes)
  - Keywords: All 21 keywords mapped to specific token types
  - Identifiers: Supports hyphens in names (e.g., my-function)
  - Variables: $var, $@explode, $namespace:var formats
  - Constants: $true, $false, $nil recognized as specific token types
  - Numbers: Integer, float, hex (0x), octal (0o), binary (0b), rationals (22/7), scientific notation
  - Operators: Comparison (==, !=, <, >, <=, >=), arithmetic (+, -, *, /, %), range (.., ..=)
  - Punctuation: All brackets, braces, parens, semicolons, etc.
- Added test framework dependencies to build.gradle.kts (JUnit 4.13.2, IntelliJ test framework)
- Created comprehensive unit tests (30+ test cases) covering all token types

**Files created:**
- src/main/kotlin/com/elvish/plugin/parser/ElvishLexer.kt
- src/test/kotlin/com/elvish/plugin/parser/ElvishLexerTest.kt

**Files changed:**
- build.gradle.kts (added testImplementation and testFramework dependencies)

**Learnings:**
- LexerBase provides a clean interface for implementing custom lexers
- IntelliJ lexers return IElementType tokens and manage buffer positions manually
- Elvish allows hyphens in identifiers, which is unusual compared to most languages
- Rational numbers (e.g., 22/7) are represented as FLOAT tokens
- The `>>` redirect operator is context-dependent in Elvish

---

## Summary

**Completed Phases:**
- Phase 1: Project Setup (STORY-001 to STORY-003)
- Phase 2: File Type Registration (STORY-004 to STORY-007)
- Phase 3: LSP Integration (STORY-008 to STORY-009)
- Phase 4: TextMate Syntax Highlighting (STORY-010 to STORY-013)
- Phase 5 (partial): Token types and lexer (STORY-014 to STORY-015)

**Remaining Phases:**
- Phase 5 (remaining): Parser, ParserDefinition, registration (STORY-016 to STORY-018)
- Phase 6: Settings & Configuration (STORY-019 to STORY-022)

**Current state:**
- Plugin builds successfully with ./gradlew build
- Plugin runs in sandbox IDE with ./gradlew runIde
- .elv files recognized with custom icon
- LSP server starts when opening .elv files (requires elvish in PATH)
- TextMate syntax highlighting fully functional
- Lexer with comprehensive unit tests ready for parser integration

---

## 2026-01-20 - STORY-016: Create ElvishParser

**What was done:**
- Created ElvishElementTypes.kt with IFileElementType and element types for AST nodes:
  - Top-level: FILE, STATEMENT, CHUNK
  - Declarations: FUNCTION_DEFINITION, VARIABLE_DECLARATION, ASSIGNMENT
  - Control flow: IF_STATEMENT, ELIF_CLAUSE, ELSE_CLAUSE, WHILE_STATEMENT, FOR_STATEMENT, TRY_STATEMENT, CATCH_CLAUSE, FINALLY_CLAUSE
  - Expressions: EXPRESSION, COMMAND, PIPELINE, BINARY_EXPRESSION, INDEXING
  - Literals: STRING_LITERAL, NUMBER_LITERAL, LIST_LITERAL, MAP_LITERAL
  - Other: BLOCK, PARAMETER_LIST, ARGUMENT_LIST, VARIABLE_REFERENCE, USE_DIRECTIVE, PRAGMA_DIRECTIVE
- Created ElvishParser.kt implementing PsiParser with comprehensive parsing:
  - parseFile: Main loop consuming statements until EOF
  - parseStatement: Dispatches to specific parsers based on token type
  - parseFunctionDefinition: Handles `fn` keyword with optional name and block body
  - parseVariableStatement: Handles var/set/tmp/del with optional assignment
  - parseIfStatement: Handles if/elif/else chains with condition and blocks
  - parseWhileStatement, parseForStatement: Loop constructs
  - parseTryStatement: try/catch/finally blocks
  - parseUseDirective, parsePragmaDirective: Module and pragma handling
  - parseBlock: Block parsing with parameter list support
  - parseExpression, parseExpressionUntilBlock: Expression parsing with binary operators
  - parsePrimaryExpression: Literals, variables, grouped expressions
  - parseCommandOrExpression: Command parsing with pipeline support
  - Error recovery via advanceWithError for malformed input
- Fixed lexer bug: Range operator (1..10) was incorrectly lexed when number was followed by '..'
  - Updated lexNumber to check for digit after '.' before treating as float
- Created comprehensive unit tests (76 tests) covering:
  - All statement types (commands, declarations, control flow)
  - All expression types (binary operators, literals, variables)
  - Nested structures (function with for with if)
  - Error recovery scenarios
- Added Gradle toolchain resolver plugin (foojay-resolver-convention) for automatic JDK download

**Files created:**
- src/main/kotlin/com/elvish/plugin/parser/ElvishElementTypes.kt
- src/main/kotlin/com/elvish/plugin/parser/ElvishParser.kt
- src/test/kotlin/com/elvish/plugin/parser/ElvishParserTest.kt

**Files changed:**
- src/main/kotlin/com/elvish/plugin/parser/ElvishLexer.kt (fixed range operator lexing)
- settings.gradle.kts (added foojay resolver plugin for JDK auto-download)

**Learnings:**
- PsiBuilder marker pattern is key to AST construction: mark(), done(type), drop(), precede()
- Condition parsing in control flow must stop at LBRACE (block start) to avoid consuming the block
- Block parsing must skip whitespace before checking for RBRACE to handle whitespace between nested closing braces
- Lexer must check for digit after '.' to distinguish float (1.5) from range (1..10)
- Test PsiBuilder implementation requires implementing many interface methods as stubs

---

## Summary

**Completed Phases:**
- Phase 1: Project Setup (STORY-001 to STORY-003)
- Phase 2: File Type Registration (STORY-004 to STORY-007)
- Phase 3: LSP Integration (STORY-008 to STORY-009)
- Phase 4: TextMate Syntax Highlighting (STORY-010 to STORY-013)
- Phase 5 (partial): Token types, lexer, and parser (STORY-014 to STORY-016)

**Remaining Phases:**
- Phase 5 (remaining): ParserDefinition and registration (STORY-017 to STORY-018)
- Phase 6: Settings & Configuration (STORY-019 to STORY-022)

**Current state:**
- Plugin builds successfully with ./gradlew build
- Plugin runs in sandbox IDE with ./gradlew runIde
- .elv files recognized with custom icon
- LSP server starts when opening .elv files (requires elvish in PATH)
- TextMate syntax highlighting fully functional
- Parser with comprehensive unit tests ready for ParserDefinition integration
